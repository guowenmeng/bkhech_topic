jps

当前jvm线程数统计：
jstack 3893 |grep 'tid'| wc -l  (linux 64位系统中jvm线程默认栈大小为1MB)
jstack 1 |grep 'tid'| wc -l


查看堆内存使用情况：
jmap -heap 1

jhsdb jmap --heap --pid 1


jmap -histo:live 1| head -n 30


jmap -dump:live,format=b,file=heap.hprof 1

jmap -dump:format=b,file=heap001.hprof 1

垃圾收集统计摘要:

jstat -gcutil  pid interval times

jstat -gcutil 1294 1000 5

查看gc发生的详细原因：
jstat -gccause pid interval times


类加载信息相关

jstat -class 1



至于JVM默认启动参数，可以通过命令
java -XX:+PrintCommandLineFlags -version


---------------------------------
查看运行时所有参数：
java -XX:+PrintFlagsFinal -version


查看运行中java设置的所有修改的参数：
jinfo -flags 1

查看运行中的java实例某个参数：
jinfo -flag InitialHeapSize 1
jinfo -flag MaxHeapSize 1
jinfo -flag NativeMemoryTracking 1
------------------------------


查看Eden 和 两个 Survivor 区域比例：
jinfo -flag SurvivorRatio 1

查看新生代 ( Young ) 与老年代 ( Old ) 的比例:
jinfo -flag NewRatio 1 



堆外内存

因为通常的垃圾收集日志等记录，并不包含 Direct Buffer 等信息，所以 Direct Buffer 内存诊断也是个比较头疼的事情。
在 JDK 8 之后的版本，使用 Native Memory Tracking （ NMT ）特性来进行诊断，你可以在程序启动时加上下面参数：
-XX:NativeMemoryTracking={off|summary|detail}
# off: 默认关闭
# summary: 只统计各个分类的内存使用情况.
# detail: Collect memory usage by individual call sites.

// 打印 NMT 信息
jcmd <pid> VM.native_memory detail

// 进行 baseline，以对比分配内存变化
jcmd <pid> VM.native_memory baseline

// 进行 diff，对比分配内存变化
jcmd <pid> VM.native_memory detail.diff